{"ast":null,"code":"var _jsxFileName = \"/Users/joshuachai/Documents/GitHub/pitch-class-set-analyzer/src/Analyzer.js\";\nimport React from 'react';\nimport setToFN from './ForteNames';\n/* This class is the meat of the SetAnalyzer.  Given a set of\n    notes, it computes its representation in zero-based pitch\n    class set notation, and then when the user clicks a button,\n    it calculates:\n        normal form (most compact permutation of the set),\n        prime form (zero based normal form OR its inversion),\n        forte number (its taxonomy according to theorist Forte), and\n        interval class vector (a vector counting its internal intervals).\n\n    The class updates its state if the set props from the parent change,\n    since the user now wants to do another computation.\n*/\n// Numerical notation for atonal music, where 0 represents\n// the pitch class C, 1 represents C#/Db, etc.\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst noteToSet = {\n  'C': 0,\n  'C#': 1,\n  'D': 2,\n  'D#': 3,\n  'E': 4,\n  'F': 5,\n  'F#': 6,\n  'G': 7,\n  'G#': 8,\n  'A': 9,\n  'A#': 10,\n  'B': 11\n};\n\nclass Analyzer extends React.Component {\n  // utility function as JS doesn't support modulo operator (dude?)\n  mod(value, mod) {\n    return (value % mod + mod) % mod;\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      normalForm: \"\",\n      primeForm: \"\",\n      icVector: \"\",\n      forteName: \"\",\n      zMate: \"None\",\n      ic_pairs: []\n    };\n    this.onCompute = this.onCompute.bind(this);\n    this.computeSetNotation = this.computeSetNotation.bind(this);\n    this.computeNormalForm = this.computeNormalForm.bind(this);\n    this.computePrimeForm = this.computePrimeForm.bind(this);\n    this.computeForteName = this.computeForteName.bind(this);\n    this.computeICVector = this.computeICVector.bind(this);\n    this.permutetwos = this.permutetwos.bind(this);\n  } // If the props have changed, we're now looking at a different set.\n  // In this case, reset state back to initial, wait for the user to \n  // say they're done with input via the onClick.\n\n\n  componentDidUpdate(prevProps) {\n    if (this.props.noteNamesOn !== prevProps.noteNamesOn) {\n      this.setState({\n        normalForm: \"\",\n        primeForm: \"\",\n        icVector: \"\",\n        forteName: \"\",\n        zMate: \"None\",\n        ic_pairs: []\n      });\n    }\n  } // This takes the props from parent and returns the \n  // set in zero-based set notation.\n\n\n  computeSetNotation() {\n    let set = [];\n\n    for (let x in this.props.noteNamesOn) {\n      set.push(noteToSet[this.props.noteNamesOn[x]]);\n    }\n\n    return /*#__PURE__*/_jsxDEV(\"span\", {\n      children: set.join(' ')\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 17\n    }, this);\n  } // We may need to normalize sets for other operations, so \n  // separating this function out...\n  // \n  // Todo:  rather than checking for ties and pulling \n  // penultimate/antepenultimate comparisons (which is traditional)\n  // we could either recurse on a smaller set or try to iterate\n  // through all distances first.  \n\n\n  normalize(arr) {\n    let size = 0;\n    let smallest = 13;\n    let smallest_index = 0;\n    let tying_index = 0;\n\n    for (let y = 0; y < arr.length; y++) {\n      size = this.mod(arr[arr.length - 1] - arr[0], 12);\n\n      if (size < smallest) {\n        smallest = size;\n        smallest_index = y;\n      }\n\n      if (size == smallest) {\n        // we have a tie!\n        // we'll store this index to compare later\n        tying_index = y;\n      } // rotate the array\n\n\n      arr.push(arr.shift());\n    }\n\n    if (tying_index > 0) {\n      // compare the first to penultimate values\n      // to establish the tiebreaker\n      let comparison1 = this.mod(smallest_index - 2, arr.length);\n      let comparison2 = this.mod(tying_index - 2, arr.length);\n\n      if (arr[comparison1] - arr[smallest_index] > arr[comparison2] - arr[tying_index]) {\n        console.log(\"here\");\n        smallest_index = tying_index;\n      }\n    } // re-arrange the array into its most compact permutation\n    // (rotate it, using shift, up to the smallest_index)\n\n\n    for (let i = 0; i < smallest_index; i++) {\n      arr.push(arr.shift());\n    }\n  }\n\n  computeNormalForm() {\n    // find the \"most compact\" form of the set\n    // (the smallest from lowest to highest).\n    // n.b.: distance from 10-2 is 4 (all math is mod12)\n    let sorted = Array.from(this.props.noteNumbersOn.sort(function (a, b) {\n      return a - b;\n    }));\n\n    for (let x in sorted) {\n      sorted[x] = sorted[x] - 48; // zero-based set\n    }\n\n    this.normalize(sorted);\n    this.setState({\n      normalForm: sorted.join(' ')\n    }, this.computePrimeForm);\n  }\n\n  computePrimeForm() {\n    // There are two candidates for a given set's prime form:\n    //   1.  Normal form, but transposed to zero (retaining structure), or,\n    //   2.  The inversion (TnI, in set theory terms) of #1.\n    // Best candidate is most compact to the left.\n    if (this.state.normalForm === \"\") {\n      return null;\n    } // Copy normal form into a new array, and manipulate.\n    // normalForm has spaces in it for display reasons, so\n    // strip those out before we manipulate\n\n\n    let prime1 = Array.from(this.state.normalForm.split(' '));\n    let first_element = Object.assign(prime1[0]);\n    prime1 = prime1.filter(item => item !== \" \");\n\n    for (let i = 0; i < prime1.length; i++) {\n      prime1[i] = this.mod(prime1[i] - first_element, 12);\n    } // sort it and normalize it\n\n\n    prime1 = prime1.sort(function (a, b) {\n      return a - b;\n    }); // We've got candidate #1.  Invert it (12-n for all elements),\n    // then transpose it to zero, then see which is more compact.\n\n    let prime2 = Array.from(prime1); // Invert the pitch classes around 0.\n\n    for (let x in prime2) {\n      prime2[x] = this.mod(12 - prime2[x], 12);\n    } // Sort it, normalize it, and set first element to zero,\n    // preserving structure.\n\n\n    prime2 = prime2.sort(function (a, b) {\n      return a - b;\n    });\n    this.normalize(prime2);\n    first_element = prime2[0];\n\n    for (let i = 0; i < prime2.length; i++) {\n      prime2[i] = this.mod(prime2[i] - first_element, 12);\n    } // If there's only one element of the set, do nothing. \n    // Otherwise, find the most compact set to the\n    // left.\n\n\n    if (prime1.length == 1) {\n      this.setState({\n        primeForm: prime1\n      });\n    } else {\n      if (prime1.length > 2 && prime1[1] - prime1[0] === prime2[1] - prime2[0]) {\n        // there's a tie, check the next element\n        if (prime1[2] - prime1[0] < prime2[2] - prime2[0]) {\n          this.setState({\n            primeForm: prime1.join(' ')\n          }, this.computeForteName);\n        } else {\n          this.setState({\n            primeForm: prime2.join(' ')\n          }, this.computeForteName);\n        }\n      } else {\n        if (prime1[1] - prime1[0] < prime2[1] - prime2[0]) {\n          this.setState({\n            primeForm: prime1.join(' ')\n          }, this.computeForteName);\n        } else {\n          this.setState({\n            primeForm: prime2.join(' ')\n          }, this.computeForteName);\n        }\n      }\n    }\n  }\n\n  computeForteName() {\n    // This one is just a lookup! Huzzah!\n    // Sets of less than three elements do not have Forte names.\n    if (this.state.primeForm.length < 5) {\n      // ... with spaces\n      this.setState({\n        forteName: \"(Set does not have a Forte name.)\"\n      }, this.computeICVector);\n    } else {\n      this.setState({\n        forteName: setToFN[this.state.primeForm]\n      }, this.computeICVector);\n    }\n  }\n\n  permutetwos(arr, temp, start, end, index) {\n    if (index == 2) {\n      for (let i = 0; i < 2; i++) {\n        this.state.ic_pairs.push(temp[i]);\n      }\n    }\n\n    for (let j = start; j <= end && end - j + 1 >= 2 - index; j++) {\n      temp[index] = arr[j];\n      this.permutetwos(arr, temp, j + 1, end, index + 1);\n    }\n  }\n\n  computeICVector() {\n    // An interval class vector always has 6 elements; \n    // each is a count of the intervals present in the set,\n    // where complementary intervals (4 and 8, for example)\n    // are counted in the same \"bucket\", as they are inversions\n    // of each other, and we hear them similarly.\n    // We could look this up like we do the Forte names, but\n    // what's the fun in that?\n    // Permute all possible combinations, store in an array.\n    // then use that array like a queue and generate distances,\n    // storing them in the vector.\n    let vector = [0, 0, 0, 0, 0, 0];\n    let arr = Array.from(this.state.primeForm.split(' '));\n    let data = new Array(2);\n    this.permutetwos(arr, data, 0, arr.length - 1, 0);\n    let k = Object.assign(this.state.ic_pairs.length / 2);\n\n    for (let i = 0; i < k; i++) {\n      let distance = this.state.ic_pairs[1] - this.state.ic_pairs[0];\n\n      switch (distance) {\n        case 1:\n        case 11:\n          vector[0]++;\n          break;\n\n        case 2:\n        case 10:\n          vector[1]++;\n          break;\n\n        case 3:\n        case 9:\n          vector[2]++;\n          break;\n\n        case 4:\n        case 8:\n          vector[3]++;\n          break;\n\n        case 5:\n        case 7:\n          vector[4]++;\n          break;\n\n        case 6:\n          vector[5]++;\n          break;\n      } // remove the first two elements and iterate\n\n\n      this.state.ic_pairs.shift();\n      this.state.ic_pairs.shift();\n    }\n\n    this.setState({\n      icVector: vector\n    });\n  }\n\n  onCompute() {\n    // computeNormalForm will be called first, but each function needs the\n    // result of the previous step.  Therefore, we'll call the first one here,\n    // but then use callbacks from setState to do the rest.\n    this.computeNormalForm();\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      class: \"ui container\",\n      children: [\"Original set: \", this.computeSetNotation(), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 313,\n        columnNumber: 58\n      }, this), \"Normal form: [\", this.state.normalForm, \"]\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 314,\n        columnNumber: 55\n      }, this), \"Prime form: (\", this.state.primeForm, \")\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 315,\n        columnNumber: 53\n      }, this), \"Forte name: \", this.state.forteName, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 51\n      }, this), \"Interval class vector: \", this.state.icVector, /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 61\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"button\",\n        onClick: this.onCompute,\n        children: \"Compute set characteristics\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 319,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 321,\n        columnNumber: 26\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 312,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default Analyzer;","map":{"version":3,"sources":["/Users/joshuachai/Documents/GitHub/pitch-class-set-analyzer/src/Analyzer.js"],"names":["React","setToFN","noteToSet","Analyzer","Component","mod","value","constructor","props","state","normalForm","primeForm","icVector","forteName","zMate","ic_pairs","onCompute","bind","computeSetNotation","computeNormalForm","computePrimeForm","computeForteName","computeICVector","permutetwos","componentDidUpdate","prevProps","noteNamesOn","setState","set","x","push","join","normalize","arr","size","smallest","smallest_index","tying_index","y","length","shift","comparison1","comparison2","console","log","i","sorted","Array","from","noteNumbersOn","sort","a","b","prime1","split","first_element","Object","assign","filter","item","prime2","temp","start","end","index","j","vector","data","k","distance","render"],"mappings":"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","sourcesContent":["import React from 'react';\nimport setToFN from './ForteNames';\n\n/* This class is the meat of the SetAnalyzer.  Given a set of\n    notes, it computes its representation in zero-based pitch\n    class set notation, and then when the user clicks a button,\n    it calculates:\n        normal form (most compact permutation of the set),\n        prime form (zero based normal form OR its inversion),\n        forte number (its taxonomy according to theorist Forte), and\n        interval class vector (a vector counting its internal intervals).\n\n    The class updates its state if the set props from the parent change,\n    since the user now wants to do another computation.\n*/\n\n// Numerical notation for atonal music, where 0 represents\n// the pitch class C, 1 represents C#/Db, etc.\nconst noteToSet = {\n    'C' : 0,\n    'C#' : 1,\n    'D' : 2,\n    'D#' : 3,\n    'E' : 4,\n    'F' : 5,\n    'F#' : 6,\n    'G' : 7,\n    'G#' : 8,\n    'A' : 9,\n    'A#' : 10,\n    'B' : 11\n}\n\nclass Analyzer extends React.Component\n{\n\n    // utility function as JS doesn't support modulo operator (dude?)\n    mod(value, mod) {\n        return ((value % mod) + mod) % mod;\n    }\n\n    constructor(props) {\n        super(props);\n        this.state = {  normalForm: \"\", \n                        primeForm: \"\", \n                        icVector: \"\", \n                        forteName: \"\", \n                        zMate: \"None\", \n                        ic_pairs: [] };\n        this.onCompute = this.onCompute.bind(this);\n        this.computeSetNotation = this.computeSetNotation.bind(this);\n        this.computeNormalForm = this.computeNormalForm.bind(this);\n        this.computePrimeForm = this.computePrimeForm.bind(this);\n        this.computeForteName = this.computeForteName.bind(this);\n        this.computeICVector = this.computeICVector.bind(this);\n        this.permutetwos = this.permutetwos.bind(this);\n    }\n\n    // If the props have changed, we're now looking at a different set.\n    // In this case, reset state back to initial, wait for the user to \n    // say they're done with input via the onClick.\n\n    componentDidUpdate(prevProps) {\n        if(this.props.noteNamesOn !== prevProps.noteNamesOn)\n        {\n            this.setState({     normalForm: \"\", \n                                primeForm: \"\", \n                                icVector: \"\", \n                                forteName: \"\", \n                                zMate: \"None\", \n                                ic_pairs: [] });\n        }\n    }\n\n    // This takes the props from parent and returns the \n    // set in zero-based set notation.\n    computeSetNotation() {\n        let set = [];\n        for(let x in this.props.noteNamesOn) {\n            set.push(noteToSet[this.props.noteNamesOn[x]]);\n        }\n        return (\n                <span>{set.join(' ')}</span>\n        )\n    }\n\n    // We may need to normalize sets for other operations, so \n    // separating this function out...\n    // \n    // Todo:  rather than checking for ties and pulling \n    // penultimate/antepenultimate comparisons (which is traditional)\n    // we could either recurse on a smaller set or try to iterate\n    // through all distances first.  \n    normalize(arr) {\n        let size = 0;\n        let smallest = 13;\n        let smallest_index = 0;\n        let tying_index = 0;\n\n        for(let y=0; y<arr.length; y++) {\n            size = this.mod((arr[arr.length-1]-arr[0]), 12);\n            if(size<smallest){\n                smallest = size;\n                smallest_index = y;\n            }\n            if(size == smallest){\n                // we have a tie!\n                // we'll store this index to compare later\n                tying_index = y;\n            }\n            // rotate the array\n            arr.push(arr.shift());\n        }\n\n        if(tying_index>0){ \n            // compare the first to penultimate values\n            // to establish the tiebreaker\n            let comparison1 = this.mod(smallest_index-2, arr.length);\n            let comparison2 = this.mod(tying_index-2, arr.length);\n            if( (arr[comparison1]-arr[smallest_index]) > \n                    (arr[comparison2]-arr[tying_index]) ) {\n                        console.log(\"here\");\n                        smallest_index = tying_index;\n                    }\n        }\n        // re-arrange the array into its most compact permutation\n        // (rotate it, using shift, up to the smallest_index)\n        for(let i=0; i<smallest_index; i++){\n            arr.push(arr.shift());\n        }\n    }\n\n    computeNormalForm()\n    {\n        // find the \"most compact\" form of the set\n        // (the smallest from lowest to highest).\n        // n.b.: distance from 10-2 is 4 (all math is mod12)\n\n        let sorted = Array.from(this.props.noteNumbersOn.sort(function(a,b){return a-b}));\n        for(let x in sorted) {\n            sorted[x] = sorted[x]-48; // zero-based set\n        }\n\n        this.normalize(sorted);\n        this.setState({ normalForm: sorted.join(' ') }, this.computePrimeForm);\n    }\n\n    computePrimeForm() {\n        // There are two candidates for a given set's prime form:\n        //   1.  Normal form, but transposed to zero (retaining structure), or,\n        //   2.  The inversion (TnI, in set theory terms) of #1.\n        // Best candidate is most compact to the left.\n\n        if(this.state.normalForm===\"\") { return null; }\n\n        // Copy normal form into a new array, and manipulate.\n        // normalForm has spaces in it for display reasons, so\n        // strip those out before we manipulate\n        let prime1 = Array.from(this.state.normalForm.split(' '));\n        let first_element = Object.assign(prime1[0]);\n        prime1 = prime1.filter((item) => item !== \" \");\n        for(let i=0; i<prime1.length; i++)\n        {\n            prime1[i] = this.mod(prime1[i]-first_element,12);\n        }\n        // sort it and normalize it\n        prime1 = prime1.sort(function(a,b){return a-b});\n        \n        // We've got candidate #1.  Invert it (12-n for all elements),\n        // then transpose it to zero, then see which is more compact.\n        let prime2 = Array.from(prime1);\n        \n        // Invert the pitch classes around 0.\n        for(let x in prime2) {\n            prime2[x] = this.mod(12-prime2[x], 12);\n        }\n\n        // Sort it, normalize it, and set first element to zero,\n        // preserving structure.\n        prime2 = prime2.sort(function(a,b){return a-b});\n        this.normalize(prime2);\n        first_element = prime2[0];\n        for(let i=0; i<prime2.length; i++)\n        {\n            prime2[i] = this.mod(prime2[i]-first_element,12);\n        }\n\n        // If there's only one element of the set, do nothing. \n        // Otherwise, find the most compact set to the\n        // left.\n\n        if(prime1.length==1) { this.setState({primeForm: prime1}); }\n        else {\n            if(prime1.length>2 && (prime1[1]-prime1[0]) === (prime2[1]-prime2[0])){\n                // there's a tie, check the next element\n                if((prime1[2]-prime1[0]) < (prime2[2]-prime2[0])){\n                    this.setState({primeForm: prime1.join(' ')}, this.computeForteName);\n                }\n                else{\n                    this.setState({primeForm: prime2.join(' ')}, this.computeForteName); \n                }\n            }\n            else{\n                if( (prime1[1]-prime1[0]) < (prime2[1]-prime2[0]) ){\n\n                    this.setState({primeForm: prime1.join(' ')}, this.computeForteName);\n                }\n                else{ \n                    this.setState({primeForm: prime2.join(' ')}, this.computeForteName); \n                }\n            }\n        }\n\n    }\n\n    computeForteName() {\n        // This one is just a lookup! Huzzah!\n        // Sets of less than three elements do not have Forte names.\n\n        if(this.state.primeForm.length < 5) { // ... with spaces\n            this.setState({ forteName: \"(Set does not have a Forte name.)\"}, this.computeICVector)\n        }\n        else {\n            this.setState({ forteName: setToFN[this.state.primeForm]}, this.computeICVector);\n        }\n    }\n\n    permutetwos(arr, temp, start, end, index)\n    {\n        if(index==2)\n        {\n            for(let i=0; i<2; i++)\n            {\n                this.state.ic_pairs.push(temp[i]);\n            }\n        }\n\n        for(let j=start; j<=end && end-j+1 >= 2-index; j++)\n        {\n            temp[index] = arr[j];\n            this.permutetwos(arr, temp, j+1, end, index+1);\n        }\n\n    }\n\n    computeICVector() {\n        // An interval class vector always has 6 elements; \n        // each is a count of the intervals present in the set,\n        // where complementary intervals (4 and 8, for example)\n        // are counted in the same \"bucket\", as they are inversions\n        // of each other, and we hear them similarly.\n\n        // We could look this up like we do the Forte names, but\n        // what's the fun in that?\n\n        // Permute all possible combinations, store in an array.\n        // then use that array like a queue and generate distances,\n        // storing them in the vector.\n\n        let vector = [0, 0, 0, 0, 0, 0];\n        let arr = Array.from(this.state.primeForm.split(' '));\n        let data = new Array(2);\n        this.permutetwos(arr, data, 0, arr.length-1, 0);\n\n        let k = Object.assign(this.state.ic_pairs.length/2);\n        for(let i=0; i<k; i++)\n        {\n            let distance = this.state.ic_pairs[1]-this.state.ic_pairs[0];\n            switch(distance)\n            {\n                case 1:\n                case 11:\n                    vector[0]++;\n                    break;\n                case 2:\n                case 10:\n                    vector[1]++;\n                    break;\n                case 3:\n                case 9:\n                    vector[2]++;\n                    break;\n                case 4:\n                case 8:\n                    vector[3]++;\n                    break;\n                case 5:\n                case 7:\n                    vector[4]++;\n                    break;\n                case 6:\n                    vector[5]++;\n                    break;\n            }\n            // remove the first two elements and iterate\n            this.state.ic_pairs.shift();\n            this.state.ic_pairs.shift();\n        }\n        this.setState({ icVector: vector });\n    }\n\n    onCompute() {\n        // computeNormalForm will be called first, but each function needs the\n        // result of the previous step.  Therefore, we'll call the first one here,\n        // but then use callbacks from setState to do the rest.\n        this.computeNormalForm();\n    }\n\n    render() {\n\n        return (\n            <div class=\"ui container\">\n                Original set: {this.computeSetNotation()}<br/>\n                Normal form: [{this.state.normalForm}]<br/>\n                Prime form: ({this.state.primeForm})<br/>\n                Forte name: {this.state.forteName}<br/>\n                Interval class vector: {this.state.icVector}<br/>\n                <br/>\n                <button type=\"button\" onClick={this.onCompute}>\n                Compute set characteristics\n                </button><br/>\n            </div>\n        )\n    }\n}\n\nexport default Analyzer"]},"metadata":{},"sourceType":"module"}